# Application development

| Recipe | Crates | Categories |
|--------|--------|------------|
| [Parse command line arguments][ex-clap-basic] | [![clap-badge]][clap] | [![cat-command-line-badge]][cat-command-line] |
| [Unzip a tarball to a temporary directory][ex-tar-temp] | [![flate2-badge]][flate2] [![tar-badge]][tar] [![tempdir-badge]][tempdir] | [![cat-filesystem-badge]][cat-filesystem] [![cat-compression-badge]][cat-compression] |
| [Recursively find duplicate file names][ex-dedup-filenames] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |
| [Recursively find all files with given predicate][ex-file-predicate] | [![walkdir-badge]][walkdir] | [![cat-filesystem-badge]][cat-filesystem] |

[ex-clap-basic]: #ex-clap-basic
<a name="ex-clap-basic"></a>
## Parse command line arguments

[![clap-badge]][clap] [![cat-command-line-badge]][cat-command-line]

```rust
extern crate clap;

use clap::{Arg, App};

fn main() {
    // Define command line arguments.
    let matches = App::new("My Test Program")
        .version("0.1.0")
        .author("Hackerman Jones <hckrmnjones@hack.gov>")
        .about("Teaches argument parsing")
        .arg(Arg::with_name("file")
                 .short("f")
                 .long("file")
                 .takes_value(true)
                 .help("A cool file"))
        .arg(Arg::with_name("num")
                 .short("n")
                 .long("number")
                 .takes_value(true)
                 .help("Five less than your favorite number"))
        .get_matches();

    // Get value for file, or default to 'input.txt'.
    let myfile = matches.value_of("file").unwrap_or("input.txt");
    println!("The file passed is: {}", myfile);

    // Get value for num if present, and try parsing it as i32.
    let num_str = matches.value_of("num");
    match num_str {
        None => println!("No idea what your favorite number is."),
        Some(s) => {
            match s.parse::<i32>() {
                Ok(n) => println!("Your favorite number must be {}.", n + 5),
                Err(_) => println!("That's not a number! {}", s),
            }
        }
    }
}
```

The `clap` crate is a simple-to-use, efficient, and full-featured library for
parsing command line arguments and subcommands when writing console/terminal
applications.

The application can describe the structure of its command-line interface using
`clap`'s builder style. The [documentation] gives two other possible ways to
instantiate an application.

[documentation]: https://docs.rs/clap/

In the builder style, `with_name` is the unique identifier that `value_of` will
use to retrieve the value passed. The `short` and `long` options control the
flag the user will be expected to type; short flags look like `-f` and long
flags look like `--file`.

Usage information is generated by `clap`. The usage for the example application
looks like this.

```
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file <file>     A cool file
    -n, --number <num>    Five less than your favorite number
```

We can test the application by running a command like the following.

```
$ cargo run -- -f myfile.txt -n 251
```

The output is:

```
The file passed is: myfile.txt
Your favorite number must be 256.
```

[ex-tar-temp]: #ex-tar-temp
<a name="ex-tar-temp"></a>
## Unzip a tarball to a temporary directory

[![flate2-badge]][flate2] [![tar-badge]][tar] [![tempdir-badge]][tempdir] [![cat-filesystem-badge]][cat-filesystem] [![cat-compression-badge]][cat-compression]

Uncompress ([`flate2::read::GzDecoder::new`]) and
extract ([`tar::Archive::unpack`]) all files form a zipped tarball
named archive.tar.gz located in the current working directory
inside a temporary directory ([`tempdir::TempDir::new`])
and delete everything.

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate flate2;
extern crate tar;
extern crate tempdir;

use std::fs::File;
use flate2::read::GzDecoder;
use tar::Archive;
use tempdir::TempDir;
#
# error_chain! {
#     foreign_links {
#         Io(std::io::Error);
#     }
# }

fn run() -> Result<()> {
    let path = "archive.tar.gz";

    // Open our zipped tarball
    let tar_gz = File::open(path)?;
    // Uncompressed it
    let tar = GzDecoder::new(tar_gz)?;
    // Load the archive from the tarball
    let mut archive = Archive::new(tar);
    // Create a directory inside of `std::env::temp_dir()`, named with
    // the prefix "temp".
    let tmp_dir = TempDir::new("temp")?;
    // Unpack the archive inside the temporary directory
    archive.unpack(tmp_dir.path())?;

    Ok(())
}
#
# quick_main!(run);
```
[ex-dedup-filenames]: #ex-dedup-filenames
<a name="ex-dedup-filenames"></a>
## Recursively find duplicate file names

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

Find recusively in the current directory duplicate filenames,
printing them only once.

```rust,no_run
extern crate walkdir;

use std::collections::HashMap;
use walkdir::WalkDir;

fn main() {
    // Counters indexed by filenames
    let mut filenames = HashMap::new();

    // List recusively all files in the current directory filtering out
    // directories and files not accessible (permission denied)
    for entry in WalkDir::new(".")
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| !e.file_type().is_dir()) {
        // Get entry's filename
        let f_name = String::from(entry.file_name().to_string_lossy());
        // Get or initialize the counter
        let counter = filenames.entry(f_name.clone()).or_insert(0);
        // Update the counter
        *counter += 1;

        if *counter == 2 {
            println!("{}", f_name);
        }
    }
}
```

[ex-file-predicate]: #ex-file-predicate
<a name="ex-file-predicate"></a>
##  Recursively find all files with given predicate

Use the file names and metadata to recursively find in the current directory JSON files modified within the last day.

[![walkdir-badge]][walkdir] [![cat-filesystem-badge]][cat-filesystem]

```rust,no_run
# #[macro_use]
# extern crate error_chain;
extern crate walkdir;

use walkdir::WalkDir;
#
# error_chain! {
#     foreign_links {
#         WalkDir(walkdir::Error);
#         Io(std::io::Error);
#         SystemTime(std::time::SystemTimeError);
#     }
# }

fn run() -> Result<()> {
    // List recusively all accessible files in the current directory
    for entry in WalkDir::new(".").into_iter().filter_map(|e| e.ok()) {
        // Get entry's filename
        let f_name = entry.file_name().to_string_lossy();
        // Get entry's modified time
        let sec = entry.metadata()?.modified()?;

        // Print JSON files modified within the last day
        if f_name.ends_with(".json") && sec.elapsed()?.as_secs() < 86400 {
            println!("{}", f_name);
        }
    }

    Ok(())
}
#
# quick_main!(run);
```

<!-- Categories -->

[cat-command-line-badge]: http://localhost:3000/badge/command_line--x.svg?style=social
[cat-command-line]: https://crates.io/categories/command-line-interface
[cat-compression-badge]: http://localhost:3000/badge/compression--x.svg?style=social
[cat-compression]: https://crates.io/categories/compression
[cat-filesystem-badge]: http://localhost:3000/badge/filesystem--x.svg?style=social
[cat-filesystem]: https://crates.io/categories/filesystem

<!-- Crates -->

[clap-badge]: http://localhost:3000/crates/v/clap.svg?label=clap
[clap]: https://docs.rs/clap/
[flate2-badge]: http://localhost:3000/crates/v/flate2.svg?label=flate2
[flate2]: https://docs.rs/flate2/
[tar-badge]: http://localhost:3000/crates/v/tar.svg?label=tar
[tar]: https://docs.rs/tar/
[tempdir-badge]: http://localhost:3000/crates/v/tempdir.svg?label=tempdir
[tempdir]: https://docs.rs/tempdir/
[walkdir-badge]: http://localhost:3000/crates/v/walkdir.svg?label=walkdir
[walkdir]: https://docs.rs/walkdir/

<!-- Reference -->

[`flate2::read::GzDecoder::new`]: https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.new
[`tar::Archive::unpack`]: https://docs.rs/tar/0.4.12/tar/struct.Archive.html#method.new
[`tempdir::TempDir::new`]: https://docs.rs/tempdir/0.3.5/tempdir/struct.TempDir.html#method.new
